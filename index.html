<!doctype html>
<html lang="el">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>SINTELIA Pulse — OPS + AXIOM A (ARM→GO, Multi-Venue)</title>
<style>
body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial;background:#fff;color:#111}
.wrap{max-width:560px;margin:auto;padding:14px}
.top{display:flex;justify-content:space-between;align-items:flex-start;gap:10px}
.state{font-size:30px;font-weight:900;padding:14px;border-radius:16px;margin-top:12px;text-align:center}
.hold{background:#fff8e6;border:1px solid #f2ddaa}
.arm{background:#eef3ff;border:1px solid #c7d6ff}
.go{background:#e9fbef;border:1px solid #bfeccc}
.nogo{background:#ffecec;border:1px solid #f0b5b5}
.sub{display:flex;gap:10px;margin-top:8px;flex-wrap:wrap}
.pill{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid #eee;background:#fafafa}
.signal{text-align:center;font-size:18px;font-weight:900;margin-top:6px}
.timer{text-align:center;font-size:12px;opacity:.70;margin-top:6px;line-height:1.25}
.card{border:1px solid #eee;border-radius:16px;padding:14px;margin-top:12px}
.bar{height:12px;background:#eee;border-radius:8px;overflow:hidden;position:relative;margin-top:8px}
.fill{height:100%;width:0%;background:#1a8f3a;transition:width .25s}
.confText{position:absolute;top:-18px;right:0;font-size:12px;opacity:.7}
.row{display:flex;justify-content:space-between;font-size:13px;margin-top:8px;opacity:.75}
.grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-top:10px}
.box{border:1px solid #eee;border-radius:12px;padding:10px}
.k{font-size:12px;opacity:.65}
.v{font-size:16px;font-weight:900;margin-top:4px}
canvas{width:100%;height:120px;margin-top:10px;border-radius:10px;background:#fafafa;border:1px solid #eee}
.mode{display:flex;gap:8px;justify-content:center;align-items:center;margin-top:12px;flex-wrap:wrap}
button,select,input{padding:6px 10px;border-radius:10px;border:1px solid #ccc;background:#fff;font-weight:800}
button{background:#fafafa;cursor:pointer}
button.active{background:#111;color:#fff;border-color:#111}
pre{font-size:11px;background:#fafafa;border:1px solid #eee;padding:10px;border-radius:12px;max-height:220px;overflow:auto}
small{opacity:.78}
.badge{font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid #eee;background:#fafafa;font-weight:900}
.err{color:#b00020;font-weight:900}
.ok{color:#1a8f3a;font-weight:900}

/* Radar */
#radar{position:fixed;right:10px;top:72px;width:220px;background:#fff;border:1px solid #eee;border-radius:14px;padding:10px;box-shadow:0 2px 10px rgba(0,0,0,.04);z-index:9999}
#radar h4{margin:0 0 8px 0;font-size:12px;opacity:.85}
#coinList{margin:0;padding:0;max-height:62vh;overflow:auto}
#coinList li{list-style:none;padding:8px 8px;border-radius:10px;margin-bottom:6px;cursor:pointer;border:1px solid #eee;background:#fafafa;display:grid;grid-template-columns:1fr auto;row-gap:2px}
#coinList li small{opacity:.72;font-weight:900}
#coinList li.hot{background:#e9fbef;border-color:#bfeccc}
#coinList li.warm{background:#fff8e6;border-color:#f2ddaa}
#coinList li.sel{outline:2px solid #111}
</style>
</head>

<body>

<div id="radar">
  <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
    <h4 style="margin:0">Radar (ARM proximity)</h4>
    <div id="scanBadge" class="badge">SCAN: OFF</div>
  </div>
  <ul id="coinList"></ul>
  <div style="font-size:11px;opacity:.7;margin-top:6px;line-height:1.2">
    Πράσινο = “ωρίμανση” προς ARM (score + ⏱ χρόνο ≥ warm).
  </div>
</div>

<div class="wrap">
  <div class="top">
    <div>
      <b>SINTELIA Pulse</b><br>
      <small id="subline">Multi-venue: Coinbase + Kraken (via Worker)</small>
    </div>
    <div>
      <div id="conn">CONNECTING</div>
      <div style="margin-top:6px;display:flex;gap:6px;align-items:center;justify-content:flex-end;flex-wrap:wrap">
        <input id="apiInput" style="width:280px" placeholder="Worker base URL (no trailing slash)">
        <button id="btnApplyApi">Apply</button>
        <button id="btnTestApi">Test</button>
      </div>
    </div>
  </div>

  <div id="state" class="state hold">HOLD</div>

  <div class="sub">
    <div id="axiomPill" class="pill">AXIOM A: —</div>
    <div id="agreePill" class="pill">VENUES: —</div>
    <div id="regimePill" class="pill">REGIME: —</div>
  </div>

  <div id="signal" class="signal">→ WAIT</div>
  <div id="goTimer" class="timer"></div>

  <div class="card">
    <div><b id="price">€ —</b></div>
    <small id="priceMeta">—</small>

    <div class="bar">
      <div id="confFill" class="fill"></div>
      <div id="confText" class="confText">0%</div>
    </div>
    <small>Confidence (adaptive smoothed)</small>

    <div class="row">
      <div>Min: <b id="minP">—</b></div>
      <div>Max: <b id="maxP">—</b></div>
    </div>

    <canvas id="chart" width="560" height="120"></canvas>

    <div class="grid">
      <div class="box"><div class="k">Momentum</div><div id="momV" class="v">—</div><div class="k" id="momK">—</div></div>
      <div class="box"><div class="k">Stability</div><div id="stabV" class="v">—</div><div class="k" id="stabK">—</div></div>
      <div class="box"><div class="k">Chop</div><div id="chopV" class="v">—</div><div class="k" id="chopK">—</div></div>
      <div class="box"><div class="k">PASS streak</div><div id="streakV" class="v">—</div><div class="k" id="streakK">—</div></div>
    </div>

    <div class="mode">
      <select id="symbolSel"></select>
      <button id="btnScan">Scan: OFF</button>
      <button id="btnQuiet">Quiet: OFF</button>
      <select id="modeSel">
        <option value="auto">Auto</option>
        <option value="calm">Calm</option>
        <option value="fast">Fast</option>
      </select>
    </div>

    <details open style="margin-top:12px">
      <summary>Diagnostics</summary>
      <div id="diag" style="font-size:12px;margin-top:8px">—</div>
      <pre id="log"></pre>
    </details>
  </div>
</div>

<script>
"use strict";

/* ===== API (Worker) ===== */
let API = localStorage.getItem("SINTELIA_API") || "https://patient-hill-56b3.fuffy1603.workers.dev";
const apiInput = document.getElementById("apiInput");
apiInput.value = API;

function normalizeApi(u){
  u = (u||"").trim();
  if(u.endsWith("/")) u = u.slice(0,-1);
  return u;
}

/* ===== Universe ===== */
const COINS = [
  "BTC-EUR","ETH-EUR","SOL-EUR","XRP-EUR",
  "ADA-EUR","AVAX-EUR","LINK-EUR","DOT-EUR",
  "LTC-EUR","DOGE-EUR"];

/* ===== Timing ===== */
const POLL_MS = 1000;
const SCAN_TICK_MS = 1500;

/* ===== Windows ===== */
const PROJ_W = [5, 15, 60, 180];
const CHART_W = 60;

/* ===== ARM/GO thresholds ===== */
const WARM = 0.55;
const HOT = 0.78;

const MIN_DWELL_ENTER_ARM_MS = 4000;
const MIN_DWELL_ENTER_GO_MS  = 14000; // stricter GO
const MIN_DWELL_EXIT_GO_MS   = 1500;

const PASS_PERSIST_MS_CALM = 16000;
const PASS_PERSIST_MS_FAST = 24000;

const FALSE_GO_WINDOW_MS = 9000;
const PENALTY_MS = 90000;

/* ===== UI helpers ===== */
const el = (id)=>document.getElementById(id);
const logEl = el("log");
function log(t){ const ts=new Date().toISOString().slice(11,19); logEl.textContent += `[${ts}] ${t}\n`; logEl.scrollTop=logEl.scrollHeight; }
function setConn(t){ el("conn").textContent=t; }
function setConf(p){ p=Math.max(0,Math.min(100,p)); el("confFill").style.width=p+"%"; el("confText").textContent=p+"%"; }
function symShort(s){ return s.replace("-EUR",""); }

/* ===== Core message (must appear) ===== */
const GO_MSG = `Το GO δεν λέει “αγόρασε”.<br>Λέει:<br>«Αν θες να αγοράσεις, ΤΩΡΑ έχει νόημα να το σκεφτείς.»`;

/* ===== Controls ===== */
let QUIET=false, MODE="auto", REGIME="calm", SCAN=false;

el("btnQuiet").onclick=()=>{ QUIET=!QUIET; el("btnQuiet").textContent=`Quiet: ${QUIET?"ON":"OFF"}`; };
el("modeSel").onchange=()=>{ MODE=el("modeSel").value; log("mode="+MODE); };
el("btnScan").onclick=()=>{ SCAN=!SCAN; el("btnScan").classList.toggle("active",SCAN); el("btnScan").textContent=`Scan: ${SCAN?"ON":"OFF"}`; el("scanBadge").textContent=`SCAN: ${SCAN?"ON":"OFF"}`; log("scan="+SCAN); };

el("btnApplyApi").onclick=()=>{
  const v=normalizeApi(apiInput.value);
  if(!v) return;
  API=v; localStorage.setItem("SINTELIA_API",API);
  log("API="+API);
};
el("btnTestApi").onclick=async()=>{
  try{
    const j = await fetchJson(normalizeApi(API)+"/health");
    el("diag").innerHTML = `<span class="ok">HEALTH OK</span> <small>${API}</small>`;
    log("health ok");
  }catch(e){
    el("diag").innerHTML = `<span class="err">HEALTH FAIL: ${String(e).slice(0,160)}</span>`;
    log("health fail: "+String(e).slice(0,140));
  }
};

/* ===== Fetch ===== */
async function fetchJson(url){
  const r = await fetch(url, { cache:"no-store" });
  const txt = await r.text();
  let j=null; try{ j=JSON.parse(txt);}catch{}
  if(!r.ok) throw new Error(`HTTP ${r.status} :: ${txt.slice(0,180)}`);
  if(j && j.ok===false) throw new Error(`${j.error||"ok:false"} :: ${txt.slice(0,180)}`);
  return j;
}
async function fetchBundle(symbol){
  const url = normalizeApi(API) + "/?symbol=" + encodeURIComponent(symbol);
  return await fetchJson(url);
}

/* ===== Memory per coin (per venue) ===== */
function makeCoin(){
  return {
    cb: { samples: [] },   // [t, price]
    kr: { samples: [] },
    merged: { samples: [] },

    lastGood: 0,
    lastState: "HOLD",
    lastChange: 0,

    passStreakMs: 0,
    confEMA: 0,
    confVelEMA: 0,
    prevConfRaw: 0,

    goStart: null,
    goEnteredAt: null,

    penaltyUntil: 0,
  };
}
const coinState = Object.fromEntries(COINS.map(c=>[c, makeCoin()]));
let SYMBOL = COINS[0];
let S = coinState[SYMBOL];

/* ===== Radar memory (score + warm time continues while ≥ warm) ===== */
const radarMem = Object.fromEntries(COINS.map(c=>[c,{score:0, warmMs:0, lastTick:0}]));
function updateRadarItem(sym){
  const li = document.getElementById("rad_"+sym);
  if(!li) return;
  const m = radarMem[sym];
  li.classList.toggle("hot", m.score>=HOT);
  li.classList.toggle("warm", m.score>=WARM);
  li.innerHTML = `<b>${symShort(sym)}</b><small>${Math.round(m.score*100)}% ⏱ ${Math.floor(m.warmMs/1000)}s</small>`;
  li.classList.toggle("sel", sym===SYMBOL);
}

/* ===== UI init ===== */
(function initUI(){
  // dropdown
  const sel = el("symbolSel");
  sel.innerHTML="";
  for(const c of COINS){
    const o=document.createElement("option");
    o.value=c; o.textContent=symShort(c);
    sel.appendChild(o);
  }
  sel.value = SYMBOL;
  sel.onchange=()=>setActive(sel.value);

  // radar list
  const ul = el("coinList");
  ul.innerHTML="";
  for(const c of COINS){
    const li=document.createElement("li");
    li.id="rad_"+c;
    li.onclick=()=>setActive(c);
    ul.appendChild(li);
    updateRadarItem(c);
  }

  setStateUI("HOLD");
  setConf(0);
  el("subline").textContent = `Multi-venue: Coinbase + Kraken (via Worker) • ${symShort(SYMBOL)}`;
})();

function setActive(sym){
  if(!coinState[sym]) return;
  SYMBOL=sym; S=coinState[SYMBOL];
  el("symbolSel").value = SYMBOL;
  for(const c of COINS) updateRadarItem(c);
  el("subline").textContent = `Multi-venue: Coinbase + Kraken (via Worker) • ${symShort(SYMBOL)}`;
  repaintFromMemory();
  log("ACTIVE "+SYMBOL);
}

function setStateUI(st){
  el("state").className = "state " + (st==="GO"?"go":st==="ARM"?"arm":st==="NO-GO"?"nogo":"hold");
  el("state").textContent = st;

  if(st==="GO"){
    el("signal").textContent = "ENTER WINDOW OPEN";
  } else if(st==="ARM"){
    el("signal").textContent = "ARMING";
  } else if(st==="NO-GO"){
    el("signal").textContent = "NO";
  } else {
    el("signal").textContent = "WAIT";
  }
}

function repaintFromMemory(){
  setStateUI(S.lastState);
  setConf(Math.round(S.confEMA*100));

  if(S.merged.samples.length){
    el("price").textContent = "€ " + S.merged.samples.at(-1)[1].toFixed(6);
    drawChart(Date.now());
  } else {
    el("price").textContent = "€ —";
    el("minP").textContent = "—";
    el("maxP").textContent = "—";
  }
  updateTimerLine(Date.now());
}

/* ===== Data handling ===== */
function pushSample(buf, t, p, maxSec){
  buf.push([t,p]);
  const keepMs = maxSec*1000;
  while(buf.length && t - buf[0][0] > keepMs) buf.shift();
}

function priceAtOrBefore(samples, t){
  for(let i=samples.length-1;i>=0;i--) if(samples[i][0] <= t) return samples[i][1];
  return null;
}

function computeProj(samples, now){
  if(samples.length<2) return null;
  const pNow = samples.at(-1)[1];
  if(!Number.isFinite(pNow)) return null;

  const rets = PROJ_W.map(w=>{
    const pThen = priceAtOrBefore(samples, now - w*1000);
    return (pThen && pThen>0) ? (pNow - pThen)/pThen : null;
  });

  // chop proxy
  const wms=30*1000; let abs=0,n=0;
  for(let i=1;i<samples.length;i++){
    if(now - samples[i][0] > wms) continue;
    abs += Math.abs(samples[i][1]-samples[i-1][1]); n++;
  }
  const chop = n? abs/n : 0;

  return { pNow, rets, chop };
}

function resolveRegime(chopRel){
  if(MODE==="calm") return "calm";
  if(MODE==="fast") return "fast";
  return chopRel > 0.0010 ? "fast" : "calm";
}

/* ===== AXIOM A (strict-ish) per venue ===== */
function axiomA(proj){
  const vals = proj.rets.filter(x=>x!=null);
  if(vals.length<3) return {verdict:"INCONCLUSIVE",score:0,reason:"warmup"};

  const med = vals.slice().sort((a,b)=>a-b)[Math.floor(vals.length/2)];
  const sgn = med>0?1:med<0?-1:0;
  let agree=0;
  for(const r of vals){
    const rs=r>0?1:r<0?-1:0;
    if(sgn!==0 && rs===sgn) agree++;
  }
  const agreeF = sgn===0?0:agree/vals.length;

  const abs=vals.map(v=>Math.abs(v));
  const max=Math.max(...abs);
  const mean=abs.reduce((a,b)=>a+b,0)/abs.length;
  const spike = mean>0 ? max/mean : 1;
  const bounded = spike<=2?1:spike<=2.6?0.55:0.15;

  const chopRel = proj.pNow>0 ? (proj.chop/proj.pNow) : 0;
  const chopCap = (REGIME==="fast")?0.0012:0.0009;
  const chopPen = Math.max(0, Math.min(1, 1 - chopRel/chopCap));

  let score = Math.max(0, Math.min(1, agreeF*bounded*chopPen));

  const retThr = (REGIME==="fast")?0.00055:0.00075;
  if(Math.abs(med)<retThr) return {verdict:"INCONCLUSIVE",score,reason:"weak"};
  if(agreeF>=0.80 && bounded>=0.55 && chopPen>=0.55) return {verdict:"PASS",score,reason:"stable"};
  if(agreeF<=0.34 || bounded<=0.15) return {verdict:"FAIL",score,reason:"incoherent"};
  return {verdict:"INCONCLUSIVE",score,reason:"mixed"};
}

/* ===== Combined OPS confidence (only if both venues exist) ===== */
function opsConfidence(axCb, axKr, projMerged){
  // base: min of venue scores to enforce agreement
  const base = Math.min(axCb.score, axKr.score);

  // momentum from merged mid windows
  const vals = projMerged.rets;
  const w=[0.9,1.2,1.6,1.1];
  let m=0,ws=0;
  for(let i=0;i<vals.length;i++){
    if(vals[i]==null) continue;
    m += w[i]*vals[i]; ws += w[i];
  }
  const mom = ws? m/ws : 0;

  const chopRel = projMerged.pNow>0 ? (projMerged.chop/projMerged.pNow) : 0;
  const chopBad = chopRel > ((REGIME==="fast")?0.0012:0.0009);

  let confRaw = base;
  if(chopBad) confRaw *= 0.75;

  // add momentum only when both PASS
  if(axCb.verdict==="PASS" && axKr.verdict==="PASS"){
    const thr = (REGIME==="fast")?0.0005:0.0007;
    const gain = Math.max(0, Math.min(1, mom/thr));
    confRaw = Math.max(confRaw, 0.60*confRaw + 0.40*gain);
  }
  return { confRaw, mom, chopRel, chopBad };
}

/* ===== Decision rules (ARM→GO + invalidation) ===== */
function dwellNeeded(prev,next){
  if(prev===next) return 0;
  if(next==="GO") return MIN_DWELL_ENTER_GO_MS;
  if(next==="ARM") return MIN_DWELL_ENTER_ARM_MS;
  if(prev==="GO") return MIN_DWELL_EXIT_GO_MS;
  return 2000;
}

function updateTimerLine(now, details=null){
  const confPct = Math.round(S.confEMA*100);
  if(now < S.penaltyUntil){
    el("goTimer").innerHTML = `PENALTY (${Math.ceil((S.penaltyUntil-now)/1000)}s left) • conf ${confPct}%`;
    return;
  }
  if(S.lastState==="GO"){
    const secs = S.goStart ? Math.floor((now-S.goStart)/1000) : 0;
    el("goTimer").innerHTML = `ENTER WINDOW • GO for ${secs}s • conf ${confPct}%<br>${GO_MSG}`;
    return;
  }
  if(S.lastState==="ARM"){
    el("goTimer").innerHTML = `ARMING • conf ${confPct}% • PASS ${Math.floor(S.passStreakMs/1000)}s`;
    return;
  }
  el("goTimer").innerHTML = details ? details : "";
}

/* ===== Chart ===== */
function drawChart(now){
  const c=el("chart"), ctx=c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  const cutoff = now - CHART_W*1000;
  const pts = S.merged.samples.filter(p=>p[0]>=cutoff);
  if(pts.length<2) return;

  const vals=pts.map(p=>p[1]);
  const min=Math.min(...vals), max=Math.max(...vals);
  el("minP").textContent="€ "+min.toFixed(6);
  el("maxP").textContent="€ "+max.toFixed(6);

  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const x=(i/(pts.length-1))*c.width;
    const y=c.height-((pts[i][1]-min)/(max-min+1e-9))*c.height;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.lineWidth=2;
  ctx.strokeStyle="#1a8f3a";
  ctx.stroke();
}

/* ===== Radar scoring (proxy) uses merged momentum from SHORT buffers ===== */
function radarScoreFromMerged(samples, now){
  if(samples.length<18) return 0;
  const p0=samples.at(-1)[1];
  const p1=priceAtOrBefore(samples, now-5*1000);
  const p2=priceAtOrBefore(samples, now-15*1000);
  if(!(p0>0 && p1>0 && p2>0)) return 0;

  const r1=(p0-p1)/p1;
  const r2=(p0-p2)/p2;
  let s=0;
  if(r1>0) s+=0.38;
  if(r2>0) s+=0.38;
  const diff=Math.abs(r1-r2);
  s += (diff<0.0012)?0.24:(diff<0.0020)?0.12:0;
  return Math.max(0,Math.min(1,s));
}

/* ===== ACTIVE LOOP ===== */
async function pollActive(){
  const now = Date.now();
  try{
    const bundle = await fetchBundle(SYMBOL);
    setConn("LIVE");
    S.lastGood = now;

    const cb = bundle.venues?.coinbase;
    const kr = bundle.venues?.kraken;

    // push per venue samples if ok
    if(cb?.ok) pushSample(S.cb.samples, now, cb.price, Math.max(CHART_W, Math.max(...PROJ_W)));
    if(kr?.ok) pushSample(S.kr.samples, now, kr.price, Math.max(CHART_W, Math.max(...PROJ_W)));

    // merged display: prefer coinbase else kraken
    const best = bundle.best;
    if(best?.price) pushSample(S.merged.samples, now, best.price, Math.max(CHART_W, Math.max(...PROJ_W)));

    // UI price label includes proxy info
    const q = bundle.resolved?.quote || "—";
    el("price").textContent = `${q} ${best?.price ? Number(best.price).toFixed(6) : "—"}`;
    el("priceMeta").textContent =
      `Resolved: ${bundle.resolved?.base}-${bundle.resolved?.quote} • best=${best?.venue || "—"} • cb=${cb?.ok?"ok":"—"} • kr=${kr?.ok?"ok":"—"}`;

    // need both venues for decision
    const haveBoth = !!(cb?.ok && kr?.ok);

    // compute projections
    const projM = computeProj(S.merged.samples, now);
    const projCb = computeProj(S.cb.samples, now);
    const projKr = computeProj(S.kr.samples, now);

    if(!projM){
      el("diag").innerHTML = `<span class="err">warming up…</span>`;
      return;
    }

    const chopRel = projM.pNow>0 ? projM.chop/projM.pNow : 0;
    REGIME = resolveRegime(chopRel);
    el("regimePill").textContent = `REGIME: ${REGIME.toUpperCase()}`;

    // If missing a venue, hold and show why
    if(!haveBoth || !projCb || !projKr){
      el("agreePill").textContent = `VENUES: waiting (need BOTH)`;
      el("axiomPill").textContent = `AXIOM A: —`;
      // still chart + metrics
      drawChart(now);
      updateTimerLine(now, `Need both venues (Coinbase+Kraken) to ARM/GO. ${GO_MSG}`);
      el("diag").innerHTML = `<span class="ok">OK</span> API=${API}`;
      setStateUI("HOLD");
      return;
    }

    // AXIOM per venue
    const axCb = axiomA(projCb);
    const axKr = axiomA(projKr);

    const agree =
      (axCb.verdict==="PASS" && axKr.verdict==="PASS") ? "PASS/PASS" :
      (axCb.verdict==="FAIL" || axKr.verdict==="FAIL") ? "DISAGREE" :
      "INCONCLUSIVE";

    el("agreePill").textContent = `VENUES: ${agree}`;
    el("axiomPill").textContent = `AXIOM A: CB=${axCb.verdict} • KR=${axKr.verdict}`;

    // persistence: only counts when PASS/PASS
    if(axCb.verdict==="PASS" && axKr.verdict==="PASS") S.passStreakMs += POLL_MS;
    else S.passStreakMs = 0;

    // combined OPS confidence
    const ops = opsConfidence(axCb, axKr, projM);

    // adaptive smoothing
    const a = (REGIME==="fast") ? 0.30 : 0.16;
    S.confEMA = a*ops.confRaw + (1-a)*S.confEMA;
    const jump = Math.abs(ops.confRaw - S.prevConfRaw);
    S.prevConfRaw = ops.confRaw;
    const av = (REGIME==="fast") ? 0.25 : 0.18;
    S.confVelEMA = av*jump + (1-av)*S.confVelEMA;

    setConf(Math.round(S.confEMA*100));

    // Decision: venue agreement required
    let next = "HOLD";
    if(agree==="DISAGREE") next="NO-GO";
    else if(agree==="PASS/PASS") {
      const persistNeed = (REGIME==="fast") ? PASS_PERSIST_MS_FAST : PASS_PERSIST_MS_CALM;
      const momNeed = (REGIME==="fast") ? 0.00050 : 0.00070;
      const confNeed = (REGIME==="fast") ? 0.72 : 0.65;

      const canArm = S.confEMA >= 0.50 && !ops.chopBad;
      const canGo  = (S.passStreakMs >= persistNeed) && (ops.mom > momNeed) && (S.confEMA >= confNeed) && (!ops.chopBad) && (now >= S.penaltyUntil);

      if(canGo) next="GO";
      else if(canArm) next="ARM";
      else next="HOLD";
    } else {
      next="HOLD";
    }

    // dwell guard
    const need = dwellNeeded(S.lastState, next);
    if(next!==S.lastState && (now - S.lastChange) < need) next = S.lastState;

    // Post-GO invalidation: if we were GO and lose PASS/PASS or chopBad -> exit immediately
    if(S.lastState==="GO" && next!=="GO"){
      const dur = S.goEnteredAt ? (now - S.goEnteredAt) : 999999;
      if(dur < FALSE_GO_WINDOW_MS){
        S.penaltyUntil = now + PENALTY_MS;
        log(`FALSE-GO ${symShort(SYMBOL)} dur=${Math.floor(dur/1000)}s → penalty ${Math.floor(PENALTY_MS/1000)}s`);
      }
    }

    // apply transition
    if(next !== S.lastState){
      S.lastState = next;
      S.lastChange = now;
      if(next==="GO"){ S.goStart=now; S.goEnteredAt=now; log(`GO ${symShort(SYMBOL)} conf=${Math.round(S.confEMA*100)}%`); }
      else { S.goStart=null; S.goEnteredAt=null; }
    }

    setStateUI(S.lastState);
    updateTimerLine(now);

    // panels
    el("momV").textContent = (ops.mom*100).toFixed(3) + "%";
    el("momK").textContent = `${PROJ_W.join("/")}s weighted return`;
    el("chopV").textContent = (ops.chopRel*100).toFixed(3) + "%";
    el("chopK").textContent = ops.chopBad ? "chop high" : "chop ok";
    el("stabV").textContent = Math.round(Math.min(axCb.score, axKr.score)*100) + "%";
    el("stabK").textContent = "min(score CB, score KR)";
    el("streakV").textContent = Math.floor(S.passStreakMs/1000) + "s";
    el("streakK").textContent = "PASS/PASS persistence";

    drawChart(now);
    el("diag").innerHTML = `<span class="ok">OK</span> API=${API}`;

  }catch(e){
    el("diag").innerHTML = `<span class="err">${String(e).slice(0,200)}</span><br><small>API=${API}</small>`;
    if(now - S.lastGood > 4000) setConn("CONNECT");
  }
}

/* ===== SCAN LOOP (Radar) ===== */
async function pollScan(){
  if(!SCAN) return;
  const now = Date.now();
  // scan each coin sequentially (keeps load low and stable)
  for(const sym of COINS){
    try{
      const bundle = await fetchBundle(sym);
      const best = bundle.best;
      if(best?.price){
        const cs = coinState[sym];
        // keep a tiny merged buffer even while not active (so click isn't empty)
        pushSample(cs.merged.samples, now, best.price, Math.max(CHART_W, Math.max(...PROJ_W)));

        const score = radarScoreFromMerged(cs.merged.samples, now);
        const m = radarMem[sym];
        const dt = m.lastTick ? (now - m.lastTick) : 0;
        m.lastTick = now;
        m.score = score;

        if(score >= WARM) m.warmMs += dt;
        else m.warmMs = 0;

        updateRadarItem(sym);
      }
    }catch{
      const m = radarMem[sym];
      m.score = 0; m.warmMs = 0; m.lastTick = now;
      updateRadarItem(sym);
    }
  }
}

/* ===== BOOT ===== */
setConn("CONNECTING");
log("boot");
setInterval(pollActive, POLL_MS);
setInterval(pollScan, SCAN_TICK_MS);
pollActive();
</script>
</body>
</html>
