<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>SINTELIA Pulse — OPS + AXIOM A (Coinbase)</title>

<style>
  body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial;background:#fff;color:#111}
  .wrap{max-width:560px;margin:auto;padding:14px}
  .top{display:flex;justify-content:space-between;align-items:center}
  .state{font-size:30px;font-weight:900;padding:14px;border-radius:16px;margin-top:12px;text-align:center}
  .hold{background:#fff8e6;border:1px solid #f2ddaa}
  .go{background:#e9fbef;border:1px solid #bfeccc}
  .nogo{background:#ffecec;border:1px solid #f0b5b5}
  .sub{display:flex;justify-content:space-between;gap:10px;margin-top:8px;align-items:center;flex-wrap:wrap}
  .pill{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid #eee;background:#fafafa}
  .signal{text-align:center;font-size:18px;font-weight:800;margin-top:6px}
  .timer{text-align:center;font-size:12px;opacity:.65;margin-top:4px}

  .card{border:1px solid #eee;border-radius:16px;padding:14px;margin-top:12px}
  .bar{height:12px;background:#eee;border-radius:8px;overflow:hidden;position:relative;margin-top:8px}
  .fill{height:100%;width:0%;background:#1a8f3a;transition:width .25s}
  .confText{position:absolute;top:-18px;right:0;font-size:12px;opacity:.7}

  .row{display:flex;justify-content:space-between;font-size:13px;margin-top:8px;opacity:.75}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-top:10px}
  .box{border:1px solid #eee;border-radius:12px;padding:10px}
  .k{font-size:12px;opacity:.65}
  .v{font-size:16px;font-weight:800;margin-top:4px}

  canvas{width:100%;height:120px;margin-top:10px;border-radius:10px;background:#fafafa;border:1px solid #eee}

  .mode{display:flex;gap:8px;justify-content:center;align-items:center;margin-top:12px;flex-wrap:wrap}
  button{padding:6px 10px;border-radius:10px;border:1px solid #ccc;background:#fafafa;font-weight:700}
  button.active{border-color:#111;background:#f3f3f3}
  select{padding:6px 10px;border-radius:10px;border:1px solid #ccc;background:#fff;font-weight:800}

  pre{font-size:11px;background:#fafafa;border:1px solid #eee;padding:10px;border-radius:12px;max-height:240px;overflow:auto}
  small{opacity:.7}

  /* Radar panel */
  #radar{
    position:fixed;
    right:10px;
    top:72px;
    width:170px;
    background:#fff;
    border:1px solid #eee;
    border-radius:14px;
    padding:10px;
    box-shadow:0 2px 10px rgba(0,0,0,.04);
    z-index:9999;
  }
  #radar h4{margin:0 0 8px 0;font-size:12px;opacity:.85}
  #coinList{margin:0;padding:0;max-height:62vh;overflow:auto}
  #coinList li{
    list-style:none;
    padding:7px 8px;
    border-radius:10px;
    margin-bottom:6px;
    cursor:pointer;
    border:1px solid #eee;
    background:#fafafa;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
  }
  #coinList li small{opacity:.65;font-weight:700}
  #coinList li.hot{background:#e9fbef;border-color:#bfeccc}
  #coinList li.warm{background:#fff8e6;border-color:#f2ddaa}
  #coinList li.sel{outline:2px solid #111}
  #radar .hint{font-size:11px;opacity:.65;line-height:1.2;margin-top:6px}
  #radar .row2{display:flex;gap:6px;align-items:center;justify-content:space-between;margin-bottom:6px}
  #radar .row2 .badge{font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid #eee;background:#fafafa;font-weight:800}
</style>
</head>

<body>

<!-- Radar panel -->
<div id="radar">
  <div class="row2">
    <h4 style="margin:0">Coin Radar</h4>
    <div id="scanBadge" class="badge">SCAN: OFF</div>
  </div>
  <ul id="coinList"></ul>
  <div class="hint">
    Πράσινο = “πλησιάζει GO” (scan proxy).<br>
    Click coin → γίνεται ACTIVE.
  </div>
</div>

<div class="wrap">
  <div class="top">
    <div>
      <b>SINTELIA Pulse</b><br>
      <small id="subline">Coinbase spot via Cloudflare</small>
    </div>
    <div id="conn">CONNECTING</div>
  </div>

  <div id="state" class="state hold">HOLD</div>

  <div class="sub">
    <div id="opsPill" class="pill">OPS: —</div>
    <div id="axiomPill" class="pill">AXIOM A: —</div>
    <div id="regimePill" class="pill">REGIME: —</div>
  </div>

  <div id="signal" class="signal">→ WAIT</div>
  <div id="goTimer" class="timer"></div>

  <div class="card">
    <div><b id="price">€ —</b></div>

    <div class="bar">
      <div id="confFill" class="fill"></div>
      <div id="confText" class="confText">0%</div>
    </div>
    <small>Confidence (adaptive smoothed)</small>

    <div class="row">
      <div>Min: <b id="minP">—</b></div>
      <div>Max: <b id="maxP">—</b></div>
    </div>

    <canvas id="chart" width="560" height="120"></canvas>

    <div class="grid">
      <div class="box">
        <div class="k">Momentum (multi-window)</div>
        <div id="momV" class="v">—</div>
        <div class="k" id="momK">—</div>
      </div>
      <div class="box">
        <div class="k">Noise / Chop</div>
        <div id="chopV" class="v">—</div>
        <div class="k" id="chopK">—</div>
      </div>
      <div class="box">
        <div class="k">Staleness</div>
        <div id="staleV" class="v">—</div>
        <div class="k" id="staleK">—</div>
      </div>
      <div class="box">
        <div class="k">Stability score (AXIOM A)</div>
        <div id="stabV" class="v">—</div>
        <div class="k" id="stabK">—</div>
      </div>
    </div>

    <div class="mode">
      <span style="font-weight:900;">Mode</span>
      <select id="modeSel">
        <option value="auto">Auto</option>
        <option value="calm">Calm</option>
        <option value="fast">Fast</option>
      </select>

      <select id="symbolSel" title="Active coin">
        <!-- filled by JS -->
      </select>

      <button id="btnScan" class="">Scan: OFF</button>
      <button id="btnQuiet">Quiet: OFF</button>
    </div>

    <details open style="margin-top:12px">
      <summary>Log</summary>
      <pre id="log"></pre>
    </details>
  </div>
</div>

<script>
"use strict";

/* =========================
   CONFIG
========================= */
const API = "https://patient-hill-56b3.fuffy1603.workers.dev/"; // Cloudflare worker root (must support ?symbol=)
const POLL_MS = 1000;

// coins
const COINS = [
  "BTC-EUR","ETH-EUR","SOL-EUR","BNB-EUR","ADA-EUR",
  "XRP-EUR","DOGE-EUR","AVAX-EUR","LINK-EUR","MATIC-EUR"
];

// sampling
const PROJ_W = [5, 15, 60, 180];
const CHART_W = 60;

// asymmetric hysteresis / dwell
const MIN_DWELL_ENTER_GO_MS = 12000; // HOLD→GO hard
const MIN_DWELL_EXIT_GO_MS  = 1500;  // GO→HOLD easy
const MIN_DWELL_OTHER_MS    = 6000;

// persistence (regime-aware)
const PASS_PERSIST_MS_CALM = 15000;
const PASS_PERSIST_MS_FAST = 22000;

// false-GO penalty
const FALSE_GO_WINDOW_MS = 9000;
const PENALTY_MS = 90000;
const PENALTY_CONF_BONUS = 0.10;
const PENALTY_PASS_EXTRA_MS = 8000;

// beep
const BEEP_COOLDOWN_MS = 30000;

// scan mode
const SCAN_POLL_EVERY_MS = 1500; // radar refresh cadence
const SCAN_LOOKBACK = 20;        // last N prices per coin for scan proxy
const SCAN_HOT = 0.78;
const SCAN_WARM = 0.55;

/* =========================
   UI + STATE
========================= */
const el = (id) => document.getElementById(id);
const logEl = el("log");

let quiet = false;

let lastGood = 0;
let lastState = "HOLD";
let lastChange = 0;

// active symbol
let SYMBOL = "BTC-EUR";

// scan toggle
let SCAN_MODE = false;

// GO timing
let goStart = null;
let goEnteredAt = null;
let lastBeep = 0;

// samples for ACTIVE: [t_ms, price]
let samples = [];

// scan buffers per coin: {sym: [price,...]}
const scanBuf = Object.fromEntries(COINS.map(c => [c, []]));
let lastScanTick = 0;

// confidence smoothing & stability
let confEMA = 0;
let confVelEMA = 0;
let prevConfRaw = 0;

// mode/regime
let MODE = "auto";
let REGIME = "calm";

// AXIOM A persistence memory
let passStreakMs = 0;

// penalty
let penaltyUntil = 0;

// audio
let audioReady = false;
const audio = new Audio("https://actions.google.com/sounds/v1/alarms/beep_short.ogg");
document.body.addEventListener("click", () => { audioReady = true; });

function log(t){
  const ts = new Date().toISOString().slice(11,19);
  logEl.textContent += `[${ts}] ${t}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}
function setConn(txt){ el("conn").textContent = txt; }
function setPill(id, txt){ el(id).textContent = txt; }
function setConfidence(pct){
  el("confFill").style.width = pct + "%";
  el("confText").textContent = pct + "%";
}
function setStateUI(s){
  el("state").className = "state " + (s==="GO" ? "go" : s==="NO-GO" ? "nogo" : "hold");
  el("state").textContent = s;

  const sig = el("signal");
  if(s==="GO"){ sig.textContent="↑ BUY"; sig.style.color="#1a8f3a"; }
  else if(s==="NO-GO"){ sig.textContent="↓ NO"; sig.style.color="#c0352b"; }
  else { sig.textContent="→ WAIT"; sig.style.color="#777"; }
}

function resetEngine(){
  samples = [];
  confEMA = 0;
  confVelEMA = 0;
  prevConfRaw = 0;

  lastState = "HOLD";
  lastChange = 0;

  goStart = null;
  goEnteredAt = null;

  passStreakMs = 0;
  penaltyUntil = 0;

  setStateUI("HOLD");
  setConfidence(0);
  el("goTimer").textContent = "";
  el("minP").textContent = "—";
  el("maxP").textContent = "—";
  log(`engine reset (symbol=${SYMBOL})`);
}

/* =========================
   UI controls
========================= */
function symShort(sym){ return sym.replace("-EUR",""); }

function buildCoinDropdown(){
  const sel = el("symbolSel");
  sel.innerHTML = "";
  for(const c of COINS){
    const opt = document.createElement("option");
    opt.value = c;
    opt.textContent = symShort(c);
    sel.appendChild(opt);
  }
  sel.value = SYMBOL;
}
function buildRadar(){
  const ul = el("coinList");
  ul.innerHTML = "";
  for(const c of COINS){
    const li = document.createElement("li");
    li.id = "rad_" + c;
    li.innerHTML = `<span>${symShort(c)}</span><small>0%</small>`;
    li.addEventListener("click", () => {
      setActiveSymbol(c);
    });
    ul.appendChild(li);
  }
  radarSelect(SYMBOL);
}
function radarSelect(sym){
  for(const c of COINS){
    const li = el("rad_" + c);
    if(!li) continue;
    li.classList.toggle("sel", c===sym);
  }
}
function setActiveSymbol(sym){
  SYMBOL = sym;
  el("symbolSel").value = sym;
  radarSelect(sym);
  el("subline").textContent = `Coinbase spot via Cloudflare • ${symShort(SYMBOL)}`;
  log(`ACTIVE symbol=${SYMBOL}`);
  resetEngine();
}

el("modeSel").addEventListener("change", () => {
  MODE = el("modeSel").value;
  log(`mode=${MODE}`);
  resetEngine();
});
el("symbolSel").addEventListener("change", () => {
  setActiveSymbol(el("symbolSel").value);
});
el("btnQuiet").addEventListener("click", () => {
  quiet = !quiet;
  el("btnQuiet").textContent = `Quiet: ${quiet ? "ON" : "OFF"}`;
  log(`quiet=${quiet}`);
});
el("btnScan").addEventListener("click", () => {
  SCAN_MODE = !SCAN_MODE;
  el("btnScan").textContent = `Scan: ${SCAN_MODE ? "ON" : "OFF"}`;
  el("btnScan").classList.toggle("active", SCAN_MODE);
  el("scanBadge").textContent = `SCAN: ${SCAN_MODE ? "ON" : "OFF"}`;
  log(`scan=${SCAN_MODE}`);
});

/* =========================
   ACTIVE engine: projections
========================= */
function trimWindow(nowMs){
  const maxKeepMs = Math.max(CHART_W, Math.max(...PROJ_W)) * 1000;
  while(samples.length && nowMs - samples[0][0] > maxKeepMs) samples.shift();
}

function priceAtOrBefore(targetMs){
  for(let i=samples.length-1;i>=0;i--){
    if(samples[i][0] <= targetMs) return samples[i][1];
  }
  return null;
}

function computeProjections(nowMs){
  const pNow = samples.length ? samples[samples.length-1][1] : null;
  if(!Number.isFinite(pNow)) return null;

  const rets = [];
  for(const w of PROJ_W){
    const pThen = priceAtOrBefore(nowMs - w*1000);
    if(pThen == null || !Number.isFinite(pThen) || pThen <= 0) rets.push(null);
    else rets.push((pNow - pThen) / pThen);
  }

  // chop: mean absolute step over last 30s
  const chopW = 30*1000;
  let absStep = 0, nStep = 0;
  for(let i=1;i<samples.length;i++){
    if(nowMs - samples[i][0] > chopW) continue;
    absStep += Math.abs(samples[i][1] - samples[i-1][1]);
    nStep++;
  }
  const chop = nStep ? absStep / nStep : 0;

  // stale: since last price change
  let lastChMs = null;
  for(let i=samples.length-1;i>=1;i--){
    if(samples[i][1] !== samples[i-1][1]) { lastChMs = samples[i][0]; break; }
  }
  const staleSec = lastChMs ? Math.floor((nowMs - lastChMs)/1000) : Math.floor((nowMs - samples[0][0])/1000);

  // mean dt (jitter proxy)
  const m = Math.min(samples.length-1, 20);
  let dtSum=0, dtN=0;
  for(let i=samples.length-1;i>=1 && dtN<m;i--){
    dtSum += (samples[i][0]-samples[i-1][0]);
    dtN++;
  }
  const meanDt = dtN ? dtSum/dtN : POLL_MS;

  return { pNow, rets, chop, staleSec, meanDt };
}

/* =========================
   Regime (Auto)
========================= */
function resolveRegime(proj){
  if(MODE === "calm") return "calm";
  if(MODE === "fast") return "fast";
  const { chop, pNow, meanDt } = proj;
  const chopRel = pNow>0 ? chop/pNow : 0;
  const fast = (chopRel > 0.0010) || (meanDt > 1300);
  return fast ? "fast" : "calm";
}

/* =========================
   AXIOM A (strict)
========================= */
function axiomA(proj){
  const { rets, chop, pNow, staleSec } = proj;

  const valid = rets.map(r => (r==null?0:1)).reduce((a,b)=>a+b,0);
  if(valid < 3) return { verdict:"INCONCLUSIVE", score:0, reason:"warmup" };

  const vals = rets.filter(r => r!=null);
  const median = vals.slice().sort((a,b)=>a-b)[Math.floor(vals.length/2)];
  const sgn = median > 0 ? +1 : median < 0 ? -1 : 0;

  let agree = 0;
  for(const r of vals){
    const rs = r > 0 ? +1 : r < 0 ? -1 : 0;
    if(rs === sgn && sgn !== 0) agree++;
  }
  const agreeFrac = (sgn===0) ? 0 : agree / vals.length;

  const absVals = vals.map(x => Math.abs(x));
  const maxAbs = Math.max(...absVals);
  const meanAbs = absVals.reduce((a,b)=>a+b,0) / absVals.length;
  const spikeRatio = meanAbs > 0 ? (maxAbs / meanAbs) : 1;

  if(staleSec >= 25) return { verdict:"INCONCLUSIVE", score: Math.max(0, agreeFrac-0.2), reason:"stale" };

  const chopRel = pNow>0 ? chop / pNow : 0;

  const bounded = spikeRatio <= 2.0 ? 1 : spikeRatio <= 2.6 ? 0.55 : 0.15;
  const chopCap = (REGIME==="fast") ? 0.0012 : 0.0009;
  const chopPenalty = Math.max(0, Math.min(1, 1 - (chopRel / chopCap)));

  let score = Math.max(0, Math.min(1, agreeFrac * bounded * chopPenalty));

  const retThr = (REGIME === "fast") ? 0.00055 : 0.00075;

  if(Math.abs(median) < retThr) return { verdict:"INCONCLUSIVE", score, reason:"weak" };
  if(agreeFrac >= 0.80 && bounded >= 0.55 && chopPenalty >= 0.55) return { verdict:"PASS", score, reason:"stable" };
  if(agreeFrac <= 0.34 || bounded <= 0.15) return { verdict:"FAIL", score, reason:"incoherent" };
  return { verdict:"INCONCLUSIVE", score, reason:"mixed" };
}

/* =========================
   OPS (calibrated)
========================= */
function opsDecision(proj, ax){
  const { rets, chop, pNow, staleSec } = proj;

  const weights = [0.9, 1.2, 1.6, 1.1];
  let m=0, wsum=0;
  for(let i=0;i<rets.length;i++){
    if(rets[i]==null) continue;
    m += weights[i]*rets[i];
    wsum += weights[i];
  }
  const mom = wsum ? m/wsum : 0;

  const chopRel = pNow>0 ? chop/pNow : 0;
  const staleBad = staleSec >= 10;
  const chopBad  = chopRel > (REGIME==="fast"?0.0012:0.0009);

  let confRaw = ax.score;

  if(ax.verdict === "PASS"){
    const momThr = (REGIME==="fast") ? 0.00050 : 0.00070;
    const momGain = Math.max(0, Math.min(1, mom / momThr));
    confRaw = Math.max(confRaw, 0.60*confRaw + 0.40*momGain);
  }

  if(chopBad) confRaw *= 0.72;
  if(staleBad) confRaw *= 0.86;

  if(ax.verdict === "FAIL") return { cand:"NO-GO", confRaw, mom, chopRel, flags:{staleBad, chopBad}, why:"axiom_fail" };
  if(ax.verdict === "PASS") return { cand:"HOLD", confRaw, mom, chopRel, flags:{staleBad, chopBad}, why:"axiom_pass_calibrated" };

  const noMom = (REGIME==="fast") ? -0.00055 : -0.00075;
  if(mom < noMom) return { cand:"NO-GO", confRaw, mom, chopRel, flags:{staleBad, chopBad}, why:"neg_mom" };

  return { cand:"HOLD", confRaw, mom, chopRel, flags:{staleBad, chopBad}, why:"inconclusive" };
}

/* =========================
   GO gate (hard)
========================= */
function goRequirements(now, out, ax){
  const penalized = now < penaltyUntil;

  const persistNeed = (REGIME==="fast") ? PASS_PERSIST_MS_FAST : PASS_PERSIST_MS_CALM;
  const persistNeedAdj = penalized ? (persistNeed + PENALTY_PASS_EXTRA_MS) : persistNeed;

  const momNeed = (REGIME==="fast") ? 0.00050 : 0.00070;

  const confFloor = ((REGIME==="fast") ? 0.72 : 0.65) + (penalized ? PENALTY_CONF_BONUS : 0);
  const velCap = (REGIME==="fast") ? 0.075 : 0.060;

  const ok =
    (ax.verdict === "PASS") &&
    (passStreakMs >= persistNeedAdj) &&
    (out.mom > momNeed) &&
    (!out.flags.chopBad) &&
    (confEMA >= confFloor) &&
    (confVelEMA <= velCap);

  return { ok, penalized, persistNeedAdj, momNeed, confFloor, velCap };
}

/* =========================
   Chart
========================= */
function drawChart(nowMs){
  const c = el("chart"), ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);

  const cutoff = nowMs - CHART_W*1000;
  const pts = samples.filter(s => s[0] >= cutoff);
  if(pts.length < 2) return;

  const vals = pts.map(p => p[1]);
  const min = Math.min(...vals), max = Math.max(...vals);
  el("minP").textContent = "€ " + min.toFixed(6);
  el("maxP").textContent = "€ " + max.toFixed(6);

  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const x = (i/(pts.length-1))*c.width;
    const y = c.height - ((pts[i][1]-min)/(max-min+1e-9))*c.height;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#1a8f3a";
  ctx.stroke();
}

/* =========================
   Hysteresis dwell
========================= */
function dwellNeeded(prev, next){
  if(prev === next) return 0;
  if(next === "GO") return MIN_DWELL_ENTER_GO_MS;
  if(prev === "GO") return MIN_DWELL_EXIT_GO_MS;
  return MIN_DWELL_OTHER_MS;
}

/* =========================
   Scan proxy (light scoring)
   0..1 "how close to GO" (no GO given here)
========================= */
function scanScore(prices){
  const n = prices.length;
  if(n < SCAN_LOOKBACK) return 0;

  const p0 = prices[n-1];
  const p1 = prices[n-6];
  const p2 = prices[n-16];

  if(!(p0>0 && p1>0 && p2>0)) return 0;

  const r1 = (p0 - p1) / p1;
  const r2 = (p0 - p2) / p2;

  // agreement: same sign + similar magnitude
  let score = 0;
  if(r1 > 0) score += 0.38;
  if(r2 > 0) score += 0.38;

  const diff = Math.abs(r1 - r2);
  score += (diff < 0.0012) ? 0.24 : (diff < 0.0020) ? 0.12 : 0;

  // clamp
  return Math.max(0, Math.min(1, score));
}

function updateRadar(sym, score){
  const li = el("rad_" + sym);
  if(!li) return;

  li.classList.remove("hot","warm");
  if(score >= SCAN_HOT) li.classList.add("hot");
  else if(score >= SCAN_WARM) li.classList.add("warm");

  const pct = Math.round(score*100);
  li.innerHTML = `<span>${symShort(sym)}</span><small>${pct}%</small>`;
}

async function fetchPrice(symbol){
  const r = await fetch(API + "?symbol=" + encodeURIComponent(symbol), { cache:"no-store" });
  const d = await r.json();
  const price = Number(d.price);
  if(!Number.isFinite(price) || price<=0) throw new Error("bad price");
  return price;
}

/* =========================
   Main poll loop (ACTIVE)
========================= */
async function pollActive(){
  try{
    const price = await fetchPrice(SYMBOL);

    setConn("LIVE");
    lastGood = Date.now();
    el("price").textContent = "€ " + price.toFixed(6);

    const now = Date.now();
    samples.push([now, price]);
    trimWindow(now);

    const proj = computeProjections(now);
    if(!proj) return;

    REGIME = resolveRegime(proj);
    const pen = (now < penaltyUntil);
    setPill("regimePill", `REGIME: ${REGIME.toUpperCase()}${pen ? " • PENALTY" : ""}`);

    const ax = axiomA(proj);
    setPill("axiomPill", `AXIOM A: ${ax.verdict} (${ax.reason})`);

    // PASS persistence
    if(ax.verdict === "PASS") passStreakMs += POLL_MS;
    else passStreakMs = 0;

    const out = opsDecision(proj, ax);
    setPill("opsPill", `OPS: ${out.why}`);

    // confidence smoothing
    const alpha = (REGIME==="fast") ? 0.30 : 0.16;
    confEMA = alpha*out.confRaw + (1-alpha)*confEMA;

    const jump = Math.abs(out.confRaw - prevConfRaw);
    prevConfRaw = out.confRaw;
    const alphaV = (REGIME==="fast") ? 0.25 : 0.18;
    confVelEMA = alphaV*jump + (1-alphaV)*confVelEMA;

    const confPct = Math.max(0, Math.min(100, Math.round(confEMA*100)));
    setConfidence(confPct);

    // candidate -> hard GO gate
    let next = out.cand;
    const req = goRequirements(now, out, ax);

    if(req.ok) next = "GO";
    else next = (ax.verdict==="FAIL") ? "NO-GO" : (out.cand==="NO-GO" ? "NO-GO" : "HOLD");

    // dwell veto
    const need = dwellNeeded(lastState, next);
    if(next !== lastState && (now - lastChange) < need) next = lastState;

    // transitions
    if(next !== lastState){
      // false-GO collapse detection
      if(lastState === "GO" && next !== "GO"){
        const goDur = goEnteredAt ? (now - goEnteredAt) : null;
        if(goDur != null && goDur < FALSE_GO_WINDOW_MS){
          penaltyUntil = now + PENALTY_MS;
          log(`FALSE-GO detected (dur=${Math.floor(goDur/1000)}s) → penalty ${Math.floor(PENALTY_MS/1000)}s`);
        }
      }

      lastState = next;
      lastChange = now;

      if(next === "GO"){
        goEnteredAt = now;
        log(`GO armed ${symShort(SYMBOL)}: pass=${Math.floor(passStreakMs/1000)}s conf=${confPct}% mom=${(out.mom*100).toFixed(3)}% vel=${(confVelEMA*100).toFixed(2)}% ${req.penalized?"(PENALIZED)":""}`);
      } else {
        goEnteredAt = null;
      }
    }

    setStateUI(lastState);

    // GO timer / arming info
    if(lastState==="GO"){
      if(!goStart) goStart = now;
      const secs = Math.floor((now - goStart)/1000);
      el("goTimer").textContent =
        `GO for ${secs}s • conf ${confPct}% • pass ${Math.floor(passStreakMs/1000)}s • vel ${(confVelEMA*100).toFixed(2)}%`;
    } else {
      goStart = null;

      const persistNeed = (REGIME==="fast") ? PASS_PERSIST_MS_FAST : PASS_PERSIST_MS_CALM;
      const persistNeedAdj = (now < penaltyUntil) ? (persistNeed + PENALTY_PASS_EXTRA_MS) : persistNeed;

      if(ax.verdict==="PASS"){
        const remaining = Math.max(0, Math.ceil((persistNeedAdj - passStreakMs)/1000));
        el("goTimer").textContent =
          `PASS persist: ${Math.floor(passStreakMs/1000)}s / ${Math.floor(persistNeedAdj/1000)}s • need ${remaining}s • conf ${confPct}%`;
      }else if(now < penaltyUntil){
        el("goTimer").textContent = `PENALTY active (${Math.ceil((penaltyUntil-now)/1000)}s left)`;
      }else{
        el("goTimer").textContent = "";
      }
    }

    // diagnostics
    el("momV").textContent = (out.mom*100).toFixed(3) + "%";
    el("momK").textContent = `weighted multi-window return`;
    el("chopV").textContent = (out.chopRel*100).toFixed(3) + "%";
    el("chopK").textContent = out.flags.chopBad ? "chop high (reject GO)" : "chop ok";
    el("staleV").textContent = proj.staleSec + "s";
    el("staleK").textContent = out.flags.staleBad ? "stale risk" : "fresh";
    el("stabV").textContent = Math.round(ax.score*100) + "%";
    el("stabK").textContent = `${PROJ_W.join("/")}s • PASS streak ${Math.floor(passStreakMs/1000)}s`;

    drawChart(now);

    // beep on GO (cooldown)
    if(!quiet && lastState==="GO" && audioReady && (now - lastBeep) > BEEP_COOLDOWN_MS){
      audio.play().catch(()=>{});
      lastBeep = now;
    }

  }catch(e){
    if(Date.now() - lastGood > 5000) setConn("RECONNECTING");
  }
}

/* =========================
   Scan loop (RADAR)
========================= */
async function pollScan(){
  const now = Date.now();
  if(!SCAN_MODE) return;
  if(now - lastScanTick < SCAN_POLL_EVERY_MS) return;
  lastScanTick = now;

  // fetch all coins in parallel (light)
  const tasks = COINS.map(async (sym) => {
    try{
      const p = await fetchPrice(sym);
      const b = scanBuf[sym];
      b.push(p);
      if(b.length > SCAN_LOOKBACK) b.shift();
      const score = scanScore(b);
      updateRadar(sym, score);
    }catch(_e){
      updateRadar(sym, 0);
    }
  });

  await Promise.allSettled(tasks);
}

/* =========================
   Boot
========================= */
buildCoinDropdown();
buildRadar();
el("subline").textContent = `Coinbase spot via Cloudflare • ${symShort(SYMBOL)}`;
setStateUI("HOLD");
setConfidence(0);
el("scanBadge").textContent = "SCAN: OFF";

setInterval(pollActive, POLL_MS);
setInterval(pollScan, 250);
pollActive();
</script>
</body>
</html>
