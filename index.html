<!doctype html>
<html lang="el">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>SINTELIA Pulse — OPS + AXIOM A (CLEAN • ARM→GO • Multi-Venue • Audit)</title>

<style>
  :root{
    --bg:#ffffff; --fg:#111; --muted:rgba(0,0,0,.65);
    --card:#fff; --line:#e9e9e9; --soft:#fafafa;
    --hold:#fff8e6; --holdb:#f2ddaa;
    --arm:#eef3ff;  --armb:#c7d6ff;
    --go:#e9fbef;   --gob:#bfeccc;
    --bad:#ffecec;  --badb:#f0b5b5;
    --green:#1a8f3a;
  }
  body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--fg)}
  .wrap{max-width:640px;margin:auto;padding:14px}
  .top{display:flex;justify-content:space-between;align-items:flex-start;gap:10px;flex-wrap:wrap}
  .title b{font-size:15px}
  .title small{opacity:.75}
  .conn{font-weight:900}
  .state{font-size:32px;font-weight:1000;padding:16px;border-radius:18px;margin-top:12px;text-align:center}
  .hold{background:var(--hold);border:1px solid var(--holdb)}
  .arm{background:var(--arm);border:1px solid var(--armb)}
  .go{background:var(--go);border:1px solid var(--gob)}
  .nogo{background:var(--bad);border:1px solid var(--badb)}
  .sub{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  .pill{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid var(--line);background:var(--soft);font-weight:900}
  .signal{text-align:center;font-size:18px;font-weight:1000;margin-top:6px}
  .timer{text-align:center;font-size:12px;opacity:.82;margin-top:6px;line-height:1.3}
  .card{border:1px solid var(--line);border-radius:18px;padding:14px;margin-top:12px;background:var(--card)}
  .bar{height:12px;background:#eee;border-radius:8px;overflow:hidden;position:relative;margin-top:8px}
  .fill{height:100%;width:0%;background:var(--green);transition:width .25s}
  .confText{position:absolute;top:-18px;right:0;font-size:12px;opacity:.7}
  .row{display:flex;justify-content:space-between;font-size:13px;margin-top:8px;opacity:.75}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-top:10px}
  .box{border:1px solid var(--line);border-radius:14px;padding:10px;background:#fff}
  .k{font-size:12px;opacity:.65}
  .v{font-size:16px;font-weight:1000;margin-top:4px}
  canvas{width:100%;height:160px;margin-top:10px;border-radius:12px;background:var(--soft);border:1px solid var(--line)}
  .mode{display:flex;gap:8px;justify-content:center;align-items:center;margin-top:12px;flex-wrap:wrap}
  button,select,input{padding:6px 10px;border-radius:10px;border:1px solid #ccc;background:#fff;font-weight:900}
  button{background:var(--soft);cursor:pointer}
  button.active{background:#111;color:#fff;border-color:#111}
  pre{font-size:11px;background:var(--soft);border:1px solid var(--line);padding:10px;border-radius:12px;max-height:200px;overflow:auto}
  small{opacity:.78}
  .badge{font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid var(--line);background:var(--soft);font-weight:1000}
  .ok{color:var(--green);font-weight:1000}
  .err{color:#b00020;font-weight:1000}
  details summary{cursor:pointer}

  /* LEFT: GO events (audit) */
  #goLog{
    position:fixed;left:10px;top:72px;width:260px;max-height:75vh;overflow:auto;
    background:#fff;border:1px solid var(--line);border-radius:16px;padding:10px;z-index:9999;
    box-shadow:0 2px 10px rgba(0,0,0,.05)
  }
  #goLog h4{margin:0 0 8px 0;font-size:12px;opacity:.9}
  #goList{margin:0;padding:0}
  #goList li{
    list-style:none;padding:8px;border-radius:12px;margin-bottom:6px;cursor:pointer;
    border:1px solid #e6e6e6;background:#f6fff9;display:grid;grid-template-columns:1fr auto;row-gap:2px
  }
  #goList li:hover{background:#e9fbef}
  #goList li small{opacity:.7}
  #goLog .hint{font-size:11px;opacity:.72;line-height:1.2}

  /* RIGHT: Radar */
  #radar{
    position:fixed;right:10px;top:72px;width:240px;background:#fff;border:1px solid var(--line);
    border-radius:16px;padding:10px;z-index:9999;box-shadow:0 2px 10px rgba(0,0,0,.05)
  }
  #radarHead{display:flex;justify-content:space-between;align-items:center;gap:8px}
  #radar h4{margin:0;font-size:12px;opacity:.9}
  #coinList{margin:0;padding:0;max-height:62vh;overflow:auto}
  #coinList li{
    list-style:none;padding:8px;border-radius:12px;margin-bottom:6px;cursor:pointer;
    border:1px solid var(--line);background:var(--soft);
    display:grid;grid-template-columns:1fr auto;row-gap:2px
  }
  #coinList li.hot{background:#e9fbef;border-color:#bfeccc}
  #coinList li.warm{background:#fff8e6;border-color:#f2ddaa}
  #coinList li.sel{outline:2px solid #111}
  #coinList li small{opacity:.72;font-weight:1000}
</style>
</head>

<body>

<!-- LEFT GO LOG -->
<div id="goLog">
  <h4>GO Events (Audit)</h4>
  <ul id="goList"></ul>
  <div class="hint">Κλικ σε event → πάει στο coin. <br>Το GO δεν λέει “αγόρασε”. Λέει: «αν θες, τώρα έχει νόημα να το σκεφτείς».</div>
</div>

<!-- RIGHT RADAR -->
<div id="radar">
  <div id="radarHead">
    <h4>Radar (ARM proximity)</h4>
    <div id="scanBadge" class="badge">SCAN: OFF</div>
  </div>
  <ul id="coinList"></ul>
  <div class="hint">Πράσινο = score + ⏱ χρόνο ≥ warm.</div>
</div>

<div class="wrap">
  <div class="top">
    <div class="title">
      <b>SINTELIA Pulse</b><br />
      <small id="subline">Multi-venue: Coinbase + Kraken (via Worker)</small>
    </div>

    <div>
      <div style="display:flex;justify-content:flex-end;gap:8px;align-items:center;flex-wrap:wrap">
        <div id="conn" class="conn">CONNECTING</div>
        <span id="health" class="badge">health: —</span>
      </div>
      <div style="margin-top:6px;display:flex;gap:6px;align-items:center;justify-content:flex-end;flex-wrap:wrap">
        <input id="apiInput" style="width:290px" placeholder="Worker base URL (no trailing slash)" />
        <button id="btnApplyApi">Apply</button>
        <button id="btnTestApi">Test</button>
      </div>
    </div>
  </div>

  <div id="state" class="state hold">HOLD</div>

  <div class="sub">
    <div id="axiomPill" class="pill">AXIOM A: —</div>
    <div id="agreePill" class="pill">VENUES: —</div>
    <div id="regimePill" class="pill">REGIME: —</div>
  </div>

  <div id="signal" class="signal">→ WAIT</div>
  <div id="goTimer" class="timer"></div>

  <div class="card">
    <div><b id="price">€ —</b></div>
    <small id="priceMeta">—</small>

    <div class="bar">
      <div id="confFill" class="fill"></div>
      <div id="confText" class="confText">0%</div>
    </div>
    <small>Confidence (adaptive smoothed)</small>

    <div class="row">
      <div>Min: <b id="minP">—</b></div>
      <div>Max: <b id="maxP">—</b></div>
    </div>

    <canvas id="chart" width="640" height="160"></canvas>

    <div class="grid">
      <div class="box"><div class="k">Momentum</div><div id="momV" class="v">—</div><div class="k" id="momK">—</div></div>
      <div class="box"><div class="k">Stability</div><div id="stabV" class="v">—</div><div class="k" id="stabK">—</div></div>
      <div class="box"><div class="k">Chop</div><div id="chopV" class="v">—</div><div class="k" id="chopK">—</div></div>
      <div class="box"><div class="k">PASS streak</div><div id="streakV" class="v">—</div><div class="k" id="streakK">—</div></div>
    </div>

    <div class="mode">
      <select id="symbolSel"></select>

      <button id="btnScan">Scan: OFF</button>
      <button id="btnQuiet">Quiet: OFF</button>

      <select id="modeSel" title="Regime mode">
        <option value="auto" selected>Auto</option>
        <option value="calm">Calm</option>
        <option value="fast">Fast</option>
      </select>

      <button id="btnOverlay" class="active" title="GO lines + enter-window shading">GO Overlay: ON</button>

      <button id="btnExportCSV">Export CSV</button>
      <button id="btnExportJSON">Export JSON</button>
      <button id="btnClearAudit" title="Clear audit events (local)">Clear Audit</button>
    </div>

    <details open style="margin-top:12px">
      <summary>Diagnostics</summary>
      <div id="diag" style="font-size:12px;margin-top:8px">—</div>
      <pre id="log"></pre>
    </details>
  </div>
</div>

<script>
"use strict";

/* =========================
   STORAGE KEYS
========================= */
const K_API   = "SINTELIA_API";
const K_GOLOG = "SINTELIA_GOLOG_V1";

/* =========================
   API (Worker)
========================= */
let API = localStorage.getItem(K_API) || "https://patient-hill-56b3.fuffy1603.workers.dev";
const apiInput = document.getElementById("apiInput");
apiInput.value = API;
function normalizeApi(u){
  u = (u||"").trim();
  if(u.endsWith("/")) u = u.slice(0,-1);
  return u;
}

/* =========================
   UNIVERSE (coins)
========================= */
const COINS = [
  "BTC-EUR","ETH-EUR","SOL-EUR","XRP-EUR",
  "ADA-EUR","AVAX-EUR","LINK-EUR","DOT-EUR",
  "LTC-EUR","DOGE-EUR"];

/* =========================
   TIMING
========================= */
const POLL_MS = 1000;
const SCAN_TICK_MS = 1600;

/* =========================
   WINDOWS
========================= */
const PROJ_W = [5, 15, 60, 180];
const CHART_W_SEC = 180;
const KEEP_SEC = Math.max(CHART_W_SEC, Math.max(...PROJ_W) + 30);

/* =========================
   ARM/GO thresholds
========================= */
const WARM = 0.55;
const HOT  = 0.78;

const MIN_DWELL_ENTER_ARM_MS = 4500;
const MIN_DWELL_ENTER_GO_MS  = 16000;
const MIN_DWELL_EXIT_GO_MS   = 1500;

const PASS_PERSIST_MS_CALM = 18000;
const PASS_PERSIST_MS_FAST = 26000;

const FALSE_GO_WINDOW_MS = 9000;
const PENALTY_MS = 90000;

/* Enter window shading duration (visual + audit) */
const ENTER_WINDOW_MS = 60000;

/* =========================
   UI refs
========================= */
const el = (id)=>document.getElementById(id);
const logEl = el("log");
const goListEl = el("goList");
const coinListEl = el("coinList");

function log(t){
  const ts = new Date().toISOString().slice(11,19);
  logEl.textContent += `[${ts}] ${t}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}
function setConn(t){ el("conn").textContent = t; }
function symShort(s){ return s.replace("-EUR",""); }
function setConf(p){
  p = Math.max(0,Math.min(100,p));
  el("confFill").style.width = p+"%";
  el("confText").textContent = p+"%";
}

/* Required message in UI */
const GO_MSG_HTML = `Το GO δεν λέει “αγόρασε”.<br>Λέει:<br>«Αν θες να αγοράσεις, ΤΩΡΑ έχει νόημα να το σκεφτείς.»`;

/* =========================
   Controls
========================= */
let QUIET=false, MODE="auto", REGIME="calm", SCAN=false;
let OVERLAY_ON = true;

el("btnQuiet").onclick=()=>{
  QUIET=!QUIET;
  el("btnQuiet").textContent = `Quiet: ${QUIET?"ON":"OFF"}`;
};
el("modeSel").onchange=()=>{
  MODE = el("modeSel").value;
  log("mode="+MODE);
};
el("btnScan").onclick=()=>{
  SCAN=!SCAN;
  el("btnScan").classList.toggle("active",SCAN);
  el("btnScan").textContent = `Scan: ${SCAN?"ON":"OFF"}`;
  el("scanBadge").textContent = `SCAN: ${SCAN?"ON":"OFF"}`;
  log("scan="+SCAN);
};
el("btnOverlay").onclick=()=>{
  OVERLAY_ON = !OVERLAY_ON;
  el("btnOverlay").classList.toggle("active", OVERLAY_ON);
  el("btnOverlay").textContent = `GO Overlay: ${OVERLAY_ON ? "ON" : "OFF"}`;
  drawChart(Date.now());
};

el("btnApplyApi").onclick=()=>{
  const v = normalizeApi(apiInput.value);
  if(!v) return;
  API = v;
  localStorage.setItem(K_API, API);
  log("API="+API);
};
el("btnTestApi").onclick=async()=>{
  try{
    await fetchJson(normalizeApi(API)+"/health");
    el("health").textContent = "health: OK";
    el("health").className = "badge";
    log("health ok");
  }catch(e){
    el("health").textContent = "health: FAIL";
    el("health").className = "badge";
    log("health fail: "+String(e).slice(0,140));
  }
};

/* =========================
   Fetch helpers
========================= */
async function fetchJson(url){
  const r = await fetch(url, { cache:"no-store" });
  const txt = await r.text();
  let j=null; try{ j=JSON.parse(txt);}catch{}
  if(!r.ok) throw new Error(`HTTP ${r.status} :: ${txt.slice(0,180)}`);
  if(j && j.ok===false) throw new Error(`${j.error||"ok:false"} :: ${txt.slice(0,180)}`);
  return j;
}
async function fetchBundle(symbol){
  const url = normalizeApi(API) + "/?symbol=" + encodeURIComponent(symbol);
  return await fetchJson(url);
}

/* =========================
   Per-coin state
========================= */
function makeCoin(){
  return {
    cb: { samples: [] },   // [t, price]
    kr: { samples: [] },
    merged: { samples: [] },

    lastGood: 0,

    lastState: "HOLD",
    lastChange: 0,

    passStreakMs: 0,
    confEMA: 0,
    confVelEMA: 0,
    prevConfRaw: 0,

    goStart: null,
    goEnteredAt: null,

    penaltyUntil: 0,

    // Audit overlays per coin
    goEvents: [],     // {id,t,price,symbol,mode,regime,conf,passStreakSec,venues,quote,bestVenue, penaltyTriggered:false}
    winEvents: [],    // {t0,t1,id}
    maxEvents: 250
  };
}
const coinState = Object.fromEntries(COINS.map(c=>[c, makeCoin()]));

/* =========================
   Global GO log (persists)
========================= */
let globalGoLog = [];
try{
  const raw = localStorage.getItem(K_GOLOG);
  if(raw) globalGoLog = JSON.parse(raw) || [];
}catch{}
function saveGoLog(){
  localStorage.setItem(K_GOLOG, JSON.stringify(globalGoLog.slice(0,500)));
}
function clearAudit(){
  globalGoLog = [];
  saveGoLog();
  for(const c of COINS){
    coinState[c].goEvents = [];
    coinState[c].winEvents = [];
  }
  renderGoList();
  drawChart(Date.now());
  log("audit cleared");
}
el("btnClearAudit").onclick=()=>clearAudit();

/* =========================
   Active symbol
========================= */
let SYMBOL = COINS[0];
let S = coinState[SYMBOL];

/* =========================
   Radar memory
========================= */
const radarMem = Object.fromEntries(COINS.map(c=>[c,{score:0,warmMs:0,lastTick:0}]));

/* =========================
   UI init
========================= */
(function initUI(){
  // dropdown
  const sel = el("symbolSel");
  sel.innerHTML="";
  for(const c of COINS){
    const o=document.createElement("option");
    o.value=c; o.textContent=symShort(c);
    sel.appendChild(o);
  }
  sel.value = SYMBOL;
  sel.onchange=()=>setActive(sel.value);

  // radar list items
  coinListEl.innerHTML="";
  for(const c of COINS){
    const li=document.createElement("li");
    li.id="rad_"+c;
    li.onclick=()=>setActive(c);
    coinListEl.appendChild(li);
  }

  setStateUI("HOLD");
  setConf(0);
  el("subline").textContent = `Multi-venue: Coinbase + Kraken (via Worker) • ${symShort(SYMBOL)}`;
  renderRadarAll();
  renderGoList();
  updateTimerLine(Date.now());
})();

function setActive(sym){
  if(!coinState[sym]) return;
  SYMBOL=sym; S=coinState[SYMBOL];
  el("symbolSel").value = SYMBOL;
  renderRadarAll();
  el("subline").textContent = `Multi-venue: Coinbase + Kraken (via Worker) • ${symShort(SYMBOL)}`;
  repaintFromMemory();
  log("ACTIVE "+SYMBOL);
}

function setStateUI(st){
  el("state").className = "state " + (st==="GO"?"go":st==="ARM"?"arm":st==="NO-GO"?"nogo":"hold");
  el("state").textContent = st;
  el("signal").textContent =
    (st==="GO") ? "ENTER WINDOW OPEN" :
    (st==="ARM")? "ARMING" :
    (st==="NO-GO") ? "NO" : "WAIT";
}

function repaintFromMemory(){
  setStateUI(S.lastState);
  setConf(Math.round(S.confEMA*100));
  if(S.merged.samples.length){
    const last = S.merged.samples.at(-1)[1];
    el("price").textContent = "€ " + last.toFixed(6);
  } else el("price").textContent = "€ —";
  updateTimerLine(Date.now());
  drawChart(Date.now());
}

/* =========================
   Data helpers
========================= */
function pushSample(buf, t, p, keepSec){
  buf.push([t,p]);
  const keepMs = keepSec*1000;
  while(buf.length && t - buf[0][0] > keepMs) buf.shift();
}
function priceAtOrBefore(samples, t){
  for(let i=samples.length-1;i>=0;i--) if(samples[i][0] <= t) return samples[i][1];
  return null;
}
function computeProj(samples, now){
  if(samples.length<2) return null;
  const pNow = samples.at(-1)[1];
  if(!Number.isFinite(pNow)) return null;

  const rets = PROJ_W.map(w=>{
    const pThen = priceAtOrBefore(samples, now - w*1000);
    return (pThen && pThen>0) ? (pNow - pThen)/pThen : null;
  });

  // chop proxy (30s)
  const wms=30*1000; let abs=0,n=0;
  for(let i=1;i<samples.length;i++){
    if(now - samples[i][0] > wms) continue;
    abs += Math.abs(samples[i][1]-samples[i-1][1]); n++;
  }
  const chop = n? abs/n : 0;

  return { pNow, rets, chop };
}
function resolveRegime(chopRel){
  if(MODE==="calm") return "calm";
  if(MODE==="fast") return "fast";
  return chopRel > 0.0010 ? "fast" : "calm";
}

/* =========================
   AXIOM A (per venue)
========================= */
function axiomA(proj){
  const vals = proj.rets.filter(x=>x!=null);
  if(vals.length<3) return {verdict:"INCONCLUSIVE",score:0,reason:"warmup"};

  const med = vals.slice().sort((a,b)=>a-b)[Math.floor(vals.length/2)];
  const sgn = med>0?1:med<0?-1:0;

  let agree=0;
  for(const r of vals){
    const rs=r>0?1:r<0?-1:0;
    if(sgn!==0 && rs===sgn) agree++;
  }
  const agreeF = sgn===0?0:agree/vals.length;

  const abs=vals.map(v=>Math.abs(v));
  const max=Math.max(...abs);
  const mean=abs.reduce((a,b)=>a+b,0)/abs.length;
  const spike = mean>0 ? max/mean : 1;
  const bounded = spike<=2?1:spike<=2.6?0.55:0.15;

  const chopRel = proj.pNow>0 ? (proj.chop/proj.pNow) : 0;
  const chopCap = (REGIME==="fast")?0.0012:0.0009;
  const chopPen = Math.max(0, Math.min(1, 1 - chopRel/chopCap));

  let score = Math.max(0, Math.min(1, agreeF*bounded*chopPen));

  const retThr = (REGIME==="fast")?0.00055:0.00075;
  if(Math.abs(med)<retThr) return {verdict:"INCONCLUSIVE",score,reason:"weak"};
  if(agreeF>=0.80 && bounded>=0.55 && chopPen>=0.55) return {verdict:"PASS",score,reason:"stable"};
  if(agreeF<=0.34 || bounded<=0.15) return {verdict:"FAIL",score,reason:"incoherent"};
  return {verdict:"INCONCLUSIVE",score,reason:"mixed"};
}

/* =========================
   OPS confidence (requires both venues)
========================= */
function opsConfidence(axCb, axKr, projMerged){
  const base = Math.min(axCb.score, axKr.score);

  const vals = projMerged.rets;
  const w=[0.9,1.2,1.6,1.1];
  let m=0,ws=0;
  for(let i=0;i<vals.length;i++){
    if(vals[i]==null) continue;
    m += w[i]*vals[i]; ws += w[i];
  }
  const mom = ws? m/ws : 0;

  const chopRel = projMerged.pNow>0 ? (projMerged.chop/projMerged.pNow) : 0;
  const chopBad = chopRel > ((REGIME==="fast")?0.0012:0.0009);

  let confRaw = base;
  if(chopBad) confRaw *= 0.75;

  if(axCb.verdict==="PASS" && axKr.verdict==="PASS"){
    const thr = (REGIME==="fast")?0.0005:0.0007;
    const gain = Math.max(0, Math.min(1, mom/thr));
    confRaw = Math.max(confRaw, 0.60*confRaw + 0.40*gain);
  }
  return { confRaw, mom, chopRel, chopBad };
}

/* =========================
   Decision helpers
========================= */
function dwellNeeded(prev,next){
  if(prev===next) return 0;
  if(next==="GO") return MIN_DWELL_ENTER_GO_MS;
  if(next==="ARM") return MIN_DWELL_ENTER_ARM_MS;
  if(prev==="GO") return MIN_DWELL_EXIT_GO_MS;
  return 2000;
}

function updateTimerLine(now){
  const confPct = Math.round(S.confEMA*100);
  if(now < S.penaltyUntil){
    el("goTimer").innerHTML = `PENALTY (${Math.ceil((S.penaltyUntil-now)/1000)}s left) • conf ${confPct}%<br>${GO_MSG_HTML}`;
    return;
  }
  if(S.lastState==="GO"){
    const secs = S.goStart ? Math.floor((now-S.goStart)/1000) : 0;
    el("goTimer").innerHTML = `ENTER WINDOW • GO for ${secs}s • conf ${confPct}%<br>${GO_MSG_HTML}`;
    return;
  }
  if(S.lastState==="ARM"){
    el("goTimer").innerHTML = `ARMING • conf ${confPct}% • PASS ${Math.floor(S.passStreakMs/1000)}s<br>${GO_MSG_HTML}`;
    return;
  }
  el("goTimer").innerHTML = GO_MSG_HTML;
}

/* =========================
   Chart + GO overlay
========================= */
function drawChart(now){
  const c=el("chart"), ctx=c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);

  const cutoff = now - CHART_W_SEC*1000;
  const pts = S.merged.samples.filter(p=>p[0]>=cutoff);
  if(pts.length<2) return;

  const vals=pts.map(p=>p[1]);
  const min=Math.min(...vals), max=Math.max(...vals);
  el("minP").textContent="€ "+min.toFixed(6);
  el("maxP").textContent="€ "+max.toFixed(6);

  const t0 = pts[0][0], t1 = pts.at(-1)[0];
  const dt = Math.max(1, (t1 - t0));
  const px = (t)=> ( (t - t0) / dt ) * c.width;
  const py = (p)=> c.height - ((p - min)/(max-min+1e-9))*c.height;

  if(OVERLAY_ON){
    // enter windows shading
    const w0=t0,w1=t1;
    ctx.save();
    ctx.fillStyle = "rgba(26,143,58,0.08)";
    for(const w of S.winEvents){
      const a=w.t0,b=w.t1;
      if(b < w0 || a > w1) continue;
      const xa = Math.max(0, Math.min(c.width, px(Math.max(a,w0))));
      const xb = Math.max(0, Math.min(c.width, px(Math.min(b,w1))));
      const wpx = Math.max(0, xb-xa);
      if(wpx>0) ctx.fillRect(xa, 0, wpx, c.height);
    }
    ctx.restore();
  }

  // price line
  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const x=(i/(pts.length-1))*c.width;
    const y=py(pts[i][1]);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.lineWidth=2;
  ctx.strokeStyle= "--" ? "#1a8f3a" : "#1a8f3a";
  ctx.stroke();

  if(OVERLAY_ON){
    ctx.save();
    ctx.strokeStyle = "#1a8f3a";
    ctx.lineWidth = 1;
    for(const ev of S.goEvents){
      if(ev.t < t0 || ev.t > t1) continue;
      const x = px(ev.t);
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,c.height); ctx.stroke();

      const y = py(Math.max(min, Math.min(max, ev.price)));
      ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2);
      ctx.fillStyle="#1a8f3a"; ctx.fill();

      ctx.font = "10px -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial";
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillText("GO", Math.min(c.width-14, x+3), Math.max(10, y-6));
    }
    ctx.restore();
  }
}

/* =========================
   Radar scoring from merged
========================= */
function radarScoreFromMerged(samples, now){
  if(samples.length<18) return 0;
  const p0=samples.at(-1)[1];
  const p1=priceAtOrBefore(samples, now-5*1000);
  const p2=priceAtOrBefore(samples, now-15*1000);
  if(!(p0>0 && p1>0 && p2>0)) return 0;

  const r1=(p0-p1)/p1;
  const r2=(p0-p2)/p2;
  let s=0;
  if(r1>0) s+=0.38;
  if(r2>0) s+=0.38;
  const diff=Math.abs(r1-r2);
  s += (diff<0.0012)?0.24:(diff<0.0020)?0.12:0;
  return Math.max(0,Math.min(1,s));
}
function renderRadarItem(sym){
  const li = document.getElementById("rad_"+sym);
  if(!li) return;
  const m = radarMem[sym];
  li.classList.toggle("hot", m.score>=HOT);
  li.classList.toggle("warm", m.score>=WARM);
  li.classList.toggle("sel", sym===SYMBOL);
  li.innerHTML = `<b>${symShort(sym)}</b><small>${Math.round(m.score*100)}% ⏱ ${Math.floor(m.warmMs/1000)}s</small>`;
}
function renderRadarAll(){
  for(const c of COINS) renderRadarItem(c);
}

/* =========================
   GO list rendering (global)
========================= */
function renderGoList(){
  goListEl.innerHTML = "";
  // newest first
  const list = globalGoLog.slice().sort((a,b)=>b.t-a.t).slice(0,120);
  for(const ev of list){
    const li=document.createElement("li");
    li.onclick=()=>setActive(ev.symbol);
    const tStr = new Date(ev.t).toLocaleTimeString();
    li.innerHTML =
      `<b>${symShort(ev.symbol)}</b>`+
      `<small style="text-align:right">${tStr}</small>`+
      `<div style="grid-column:1 / span 2; opacity:.75; font-weight:900">€ ${Number(ev.price).toFixed(2)} • conf ${Math.round(ev.conf*100)}% • ${ev.regime}/${ev.mode}</div>`;
    goListEl.appendChild(li);
  }
}

/* =========================
   GO record + persistence
========================= */
function uid(){
  return Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}
function recordGoEvent(bundle, now){
  const quote = bundle?.resolved?.quote || "€";
  const bestVenue = bundle?.best?.venue || "—";
  const p = (bundle?.best?.price && Number.isFinite(Number(bundle.best.price))) ? Number(bundle.best.price) : (S.merged.samples.at(-1)?.[1] || NaN);
  if(!Number.isFinite(p)) return;

  const id = uid();
  const ev = {
    id,
    t: now,
    symbol: SYMBOL,
    price: p,
    quote,
    bestVenue,
    mode: MODE,
    regime: REGIME,
    conf: S.confEMA,
    passStreakSec: Math.floor(S.passStreakMs/1000),
    venues: "PASS/PASS",
    penaltyTriggered: false
  };

  S.goEvents.push(ev);
  S.winEvents.push({ t0: now, t1: now + ENTER_WINDOW_MS, id });

  if(S.goEvents.length > S.maxEvents) S.goEvents.splice(0, S.goEvents.length - S.maxEvents);
  if(S.winEvents.length > S.maxEvents) S.winEvents.splice(0, S.winEvents.length - S.maxEvents);

  globalGoLog.push(ev);
  globalGoLog = globalGoLog.slice(-500);
  saveGoLog();
  renderGoList();

  log(`GO ${symShort(SYMBOL)} €${p.toFixed(2)} conf=${Math.round(S.confEMA*100)}% ${REGIME}/${MODE}`);
}

/* If a false-go penalty triggers, mark the last GO in this coin (and global) */
function markPenaltyTriggeredForLastGo(now){
  // last in coin
  const last = S.goEvents.length ? S.goEvents[S.goEvents.length-1] : null;
  if(last && (now - last.t) < FALSE_GO_WINDOW_MS + 2000){
    last.penaltyTriggered = true;
  }
  // last in global with same id
  if(last){
    const idx = globalGoLog.findIndex(x=>x.id===last.id);
    if(idx>=0) globalGoLog[idx].penaltyTriggered = true;
    saveGoLog();
    renderGoList();
  }
}

/* =========================
   Export (CSV + JSON) with outcomes
========================= */
function sampleAtOrAfter(samples, t){
  for(let i=0;i<samples.length;i++) if(samples[i][0] >= t) return samples[i][1];
  return null;
}
function outcomeForEvent(ev){
  const cs = coinState[ev.symbol];
  const samples = cs.merged.samples;
  const t0 = ev.t;

  const p30  = sampleAtOrAfter(samples, t0 + 30*1000);
  const p60  = sampleAtOrAfter(samples, t0 + 60*1000);
  const p120 = sampleAtOrAfter(samples, t0 + 120*1000);

  // max/min in 2 minutes after GO (if we have coverage)
  let max2 = null, min2 = null;
  for(const [t,p] of samples){
    if(t < t0) continue;
    if(t > t0 + 120*1000) break;
    max2 = (max2==null)?p:Math.max(max2,p);
    min2 = (min2==null)?p:Math.min(min2,p);
  }

  return {
    price_after_30s:  p30,
    price_after_60s:  p60,
    price_after_120s: p120,
    max_price_2m: max2,
    min_price_2m: min2
  };
}
function downloadBlob(text, name, type){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text],{type}));
  a.download = name;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
}
function exportJSON(){
  const rows = globalGoLog
    .slice().sort((a,b)=>a.t-b.t)
    .map(ev=>({ ...ev, timeISO:new Date(ev.t).toISOString(), ...outcomeForEvent(ev) }));
  downloadBlob(JSON.stringify(rows,null,2), `sintelia_go_audit_${Date.now()}.json`, "application/json");
}
function exportCSV(){
  const rows = globalGoLog
    .slice().sort((a,b)=>a.t-b.t)
    .map(ev=>({ ...ev, timeISO:new Date(ev.t).toISOString(), ...outcomeForEvent(ev) }));

  const headers = [
    "timeISO","symbol","price","conf","mode","regime","passStreakSec","venues","bestVenue","quote",
    "price_after_30s","price_after_60s","price_after_120s","max_price_2m","min_price_2m",
    "penaltyTriggered"
  ];
  let csv = headers.join(",") + "\n";
  for(const r of rows){
    const vals = headers.map(k=>{
      const v = r[k];
      if(v==null || Number.isNaN(v)) return "";
      if(typeof v === "number") return String(v);
      return `"${String(v).replaceAll('"','""')}"`;
    });
    csv += vals.join(",") + "\n";
  }
  downloadBlob(csv, `sintelia_go_audit_${Date.now()}.csv`, "text/csv");
}
el("btnExportJSON").onclick=()=>exportJSON();
el("btnExportCSV").onclick=()=>exportCSV();

/* =========================
   Main loop
========================= */
async function pollActive(){
  const now = Date.now();
  try{
    const bundle = await fetchBundle(SYMBOL);
    setConn("LIVE");
    el("health").textContent = "health: OK";

    S.lastGood = now;

    const cb = bundle.venues?.coinbase;
    const kr = bundle.venues?.kraken;

    if(cb?.ok) pushSample(S.cb.samples, now, cb.price, KEEP_SEC);
    if(kr?.ok) pushSample(S.kr.samples, now, kr.price, KEEP_SEC);

    const best = bundle.best;
    if(best?.price) pushSample(S.merged.samples, now, best.price, KEEP_SEC);

    // UI price label includes quote + best venue
    const q = bundle.resolved?.quote || "€";
    el("price").textContent = `${q} ${best?.price ? Number(best.price).toFixed(6) : "—"}`;
    el("priceMeta").textContent =
      `Resolved: ${bundle.resolved?.base||"—"}-${bundle.resolved?.quote||"—"} • best=${best?.venue || "—"} • cb=${cb?.ok?"ok":"—"} • kr=${kr?.ok?"ok":"—"}`;

    const haveBoth = !!(cb?.ok && kr?.ok);

    const projM = computeProj(S.merged.samples, now);
    const projCb = computeProj(S.cb.samples, now);
    const projKr = computeProj(S.kr.samples, now);

    if(!projM){
      el("diag").innerHTML = `<span class="err">warming up…</span>`;
      updateTimerLine(now);
      drawChart(now);
      return;
    }

    const chopRel = projM.pNow>0 ? projM.chop/projM.pNow : 0;
    REGIME = resolveRegime(chopRel);
    el("regimePill").textContent = `REGIME: ${REGIME.toUpperCase()}`;

    if(!haveBoth || !projCb || !projKr){
      el("agreePill").textContent = `VENUES: waiting (need BOTH)`;
      el("axiomPill").textContent = `AXIOM A: —`;
      setStateUI("HOLD");
      updateTimerLine(now);
      drawChart(now);
      el("diag").innerHTML = `<span class="ok">OK</span> API=${API}`;
      return;
    }

    const axCb = axiomA(projCb);
    const axKr = axiomA(projKr);

    const agree =
      (axCb.verdict==="PASS" && axKr.verdict==="PASS") ? "PASS/PASS" :
      (axCb.verdict==="FAIL" || axKr.verdict==="FAIL") ? "DISAGREE" :
      "INCONCLUSIVE";

    el("agreePill").textContent = `VENUES: ${agree}`;
    el("axiomPill").textContent = `AXIOM A: CB=${axCb.verdict} • KR=${axKr.verdict}`;

    // persistence: only counts when PASS/PASS
    if(agree==="PASS/PASS") S.passStreakMs += POLL_MS;
    else S.passStreakMs = 0;

    const ops = opsConfidence(axCb, axKr, projM);

    // adaptive smoothing
    const a = (REGIME==="fast") ? 0.30 : 0.16;
    S.confEMA = a*ops.confRaw + (1-a)*S.confEMA;

    const jump = Math.abs(ops.confRaw - S.prevConfRaw);
    S.prevConfRaw = ops.confRaw;
    const av = (REGIME==="fast") ? 0.25 : 0.18;
    S.confVelEMA = av*jump + (1-av)*S.confVelEMA;

    setConf(Math.round(S.confEMA*100));

    // Decision
    let next = "HOLD";
    if(agree==="DISAGREE") next="NO-GO";
    else if(agree==="PASS/PASS") {
      const persistNeed = (REGIME==="fast") ? PASS_PERSIST_MS_FAST : PASS_PERSIST_MS_CALM;
      const momNeed = (REGIME==="fast") ? 0.00050 : 0.00070;
      const confNeed = (REGIME==="fast") ? 0.72 : 0.65;

      const canArm = S.confEMA >= 0.50 && !ops.chopBad;
      const canGo  = (S.passStreakMs >= persistNeed) && (ops.mom > momNeed) && (S.confEMA >= confNeed) && (!ops.chopBad) && (now >= S.penaltyUntil);

      if(canGo) next="GO";
      else if(canArm) next="ARM";
      else next="HOLD";
    } else {
      next="HOLD";
    }

    // dwell guard
    const need = dwellNeeded(S.lastState, next);
    if(next!==S.lastState && (now - S.lastChange) < need) next = S.lastState;

    // if leaving GO quickly => penalty
    if(S.lastState==="GO" && next!=="GO"){
      const dur = S.goEnteredAt ? (now - S.goEnteredAt) : 999999;
      if(dur < FALSE_GO_WINDOW_MS){
        S.penaltyUntil = now + PENALTY_MS;
        markPenaltyTriggeredForLastGo(now);
        log(`FALSE-GO ${symShort(SYMBOL)} dur=${Math.floor(dur/1000)}s → penalty ${Math.floor(PENALTY_MS/1000)}s`);
      }
    }

    // apply transition
    if(next !== S.lastState){
      const prev = S.lastState;
      S.lastState = next;
      S.lastChange = now;

      if(next==="GO"){
        S.goStart=now; S.goEnteredAt=now;

        // ✅ CLEAN: record GO ONLY on real transition into GO (no random, no dummy)
        recordGoEvent(bundle, now);

      } else {
        S.goStart=null; S.goEnteredAt=null;
      }

      if(prev==="GO" && next!=="GO") log(`GO EXIT → ${next} (${symShort(SYMBOL)})`);
    }

    setStateUI(S.lastState);
    updateTimerLine(now);

    // panels
    el("momV").textContent = (ops.mom*100).toFixed(3) + "%";
    el("momK").textContent = `${PROJ_W.join("/")}s weighted return`;
    el("chopV").textContent = (ops.chopRel*100).toFixed(3) + "%";
    el("chopK").textContent = ops.chopBad ? "chop high" : "chop ok";
    el("stabV").textContent = Math.round(Math.min(axCb.score, axKr.score)*100) + "%";
    el("stabK").textContent = "min(score CB, score KR)";
    el("streakV").textContent = Math.floor(S.passStreakMs/1000) + "s";
    el("streakK").textContent = "PASS/PASS persistence";

    drawChart(now);

    el("diag").innerHTML = `<span class="ok">OK</span> API=${API}`;

  }catch(e){
    el("diag").innerHTML = `<span class="err">${String(e).slice(0,220)}</span><br><small>API=${API}</small>`;
    el("health").textContent = "health: —";
    if(Date.now() - S.lastGood > 4000) setConn("CONNECT");
    if(!QUIET) log("err: "+String(e).slice(0,160));
  }
}

/* =========================
   Scan loop (Radar + background merge buffers)
========================= */
async function pollScan(){
  if(!SCAN) return;
  const now = Date.now();

  for(const sym of COINS){
    try{
      const bundle = await fetchBundle(sym);
      const best = bundle.best;
      if(best?.price){
        const cs = coinState[sym];

        // keep a merged buffer even while not active (so clicking isn't empty)
        pushSample(cs.merged.samples, now, best.price, KEEP_SEC);

        const score = radarScoreFromMerged(cs.merged.samples, now);
        const m = radarMem[sym];
        const dt = m.lastTick ? (now - m.lastTick) : 0;
        m.lastTick = now;
        m.score = score;

        if(score >= WARM) m.warmMs += dt;
        else m.warmMs = 0;

        renderRadarItem(sym);
      } else {
        const m = radarMem[sym];
        m.score = 0; m.warmMs = 0; m.lastTick = now;
        renderRadarItem(sym);
      }
    }catch{
      const m = radarMem[sym];
      m.score = 0; m.warmMs = 0; m.lastTick = now;
      renderRadarItem(sym);
    }
  }
}

/* =========================
   Boot
========================= */
(function boot(){
  // Radar DOM nodes
  coinListEl.innerHTML = "";
  for(const c of COINS){
    const li=document.createElement("li");
    li.id="rad_"+c;
    li.onclick=()=>setActive(c);
    coinListEl.appendChild(li);
  }
  renderRadarAll();

  // restore global go log into UI
  renderGoList();

  setConn("CONNECTING");
  log("boot • API="+API);
  updateTimerLine(Date.now());
  setInterval(pollActive, POLL_MS);
  setInterval(pollScan, SCAN_TICK_MS);
  pollActive();
})();
</script>
</body>
</html>
